# 修复文档：聊天消息内“文本/工具交错”收尾回退、段落空隙、任务面板时序

日期：2026-01-06  
作者：Codex

## 1. 目标与现象（按最新复现修正）

### 1.1 目标 UI（你期望的格式）

同一条助手消息（turn 容器）内，按时间顺序交错渲染：

1. 文本（段 1）
2. 工具卡片（调用 1）
3. 文本（段 2）
4. 工具卡片（调用 2）
5. 文本（段 3）

### 1.2 当前现象（你给的两张截图总结）

1. **过程阶段确实能实现交错**：运行中能看到 `文本 → [工具] → 文本 → [工具] → 文本`，说明“数据链路/渲染能力”本身已经具备。
2. **段落空隙偏大**：文本段与工具卡之间出现明显大空白（通常是“多余换行 + UI margin/padding”叠加的结果）。
3. **只在最后时刻发生回退/替换**（最关键）：
   - 原先的多段文本在最后被合并/替换成“最后一段文本”，并出现位置跳变（看起来像“跑到最上面”）。
   - 原先分散的 3 张工具卡在最后被合并成一坨（回到“聚合展示”的样子）。
4. **任务面板时序不一致**：任务面板（Overlay/M2）会在聊天工具卡尚未出现时先出现该任务，造成观感割裂。

## 2. 根因分析（以“只在收尾回退”为第一线索）

### 根因 A（最高优先级）：收尾阶段写入覆盖了最新 blocks，导致结构回退

你描述的关键特征是：**运行中交错正常，但只有最后一刻回退**。这更像是“收尾阶段某个写入/同步”在覆盖消息结构，而不是过程逻辑没有实现。

典型触发点：

- 任务状态变为 `done/failed/canceled` 后的最后一次 UI 同步
- 二段式 finalize（工具执行完后再请求一次模型生成最终回复）在流式/结束时写回消息

如果该阶段使用了“过期的基准 blocks”（例如仍是最初模板 `[..., {tool_use: taskId}, ...]`），就会：

- 把中间多段文本覆盖掉（看起来像“替换/跳变”）
- 把多个工具卡合并为“聚合渲染”（见根因 B）

### 根因 B：blocks 丢失 `runId` 或被写回为 `{tool_use: taskId}`，触发聚合渲染路径

现在 UI 同时支持两种工具展示方式：

- **精确方式**：blocks 内有多个 `{ type:'tool_use', taskId, runId }`，每个 run 一张卡，天然按顺序交错。
- **降级方式**：blocks 只有 `{ type:'tool_use', taskId }`，渲染时会把该 task 的所有 `toolRuns` 全部列出来（“一坨工具卡”）。

因此只要最后一次写回 blocks 时丢了 `runId`（或被重建成 taskId-only），最后就必然回到“一坨工具卡”的样子。

### 根因 C：段落空隙大的来源（文本换行归一 + UI 样式叠加）

空隙通常来自两部分叠加：

1. **文本内容本身带多余换行**：例如段首 `^\n+`、段尾 `\n+$`、或者工具后续文本自带空行。
2. **工具卡容器的 margin/padding/gap**：`<details>`/容器样式与文本块样式叠加，视觉上就像“断层”。

### 根因 D：任务面板与聊天工具卡的触发条件不一致

- 任务面板多由“任务创建/任务状态变化”驱动：任务一创建就能显示。
- 聊天工具卡多由“检测到工具调用/生成 blocks”驱动：可能要等到第一段可见文本或第一条 toolRun 才插入。

两者触发点不一致时，就会出现“任务面板先出现、聊天里还没工具卡”的体验割裂。

## 3. 修复策略（按收益/风险排序）

### 3.1 必须优先修：禁止收尾阶段回退 blocks 结构

硬性约束（验收标准）：

- 运行中出现过的 `text/tool_use(runId)/text/...` 结构，在任务结束后必须原样保留（只允许**追加**最后一段文本，不允许“重建模板覆盖”）。
- 任务结束后不得从“多个 tool_use(runId)”回退为“单个 tool_use(taskId)”。

实现要点（原则，不展开代码）：

- finalize/收尾写回时，必须以“最新 blocks 状态”为基准进行局部更新（只更新最后一段 text）。
- 严禁用初始化模板（或过期快照）重新生成整条 blocks。

### 3.2 固化 runId：保证持久化/回放不触发聚合降级

验收标准：

- 刷新/重启后历史消息仍按 `text → tool(runId) → text → ...` 显示，不会变成“一坨工具卡”。

实现要点：

- 对写回的 blocks 做校验：如果运行期已有 runId，就不允许写回时丢失 runId。

### 3.3 收紧空隙：先做换行归一，再调 UI 间距

建议拆开做，便于定位到底是哪一类造成的：

1. **文本归一**：新段落写入 blocks 前，对段首/段尾换行压缩（例如段首去掉 `^\n+`，段尾去掉 `\n+$`，把连续 3 个以上换行压成 1~2 个）。
2. **样式归一**：降低工具卡与文本块之间的 `margin/padding/gap`，让交错更像“同一条消息里的连续叙述”。

### 3.4 对齐任务面板显示时机

期望（你描述的体验）更像：

- 聊天里出现第一张工具卡后，任务面板再出现该任务（或至少不要“抢跑”太明显）。

可选策略（按侵入性排序）：

1. 任务面板对“chat 来源任务”延迟展示：直到出现第一条 toolRun 或聊天 blocks 首次插入 tool_use。
2. 任务面板先展示“准备中/思考中”但不占主要视觉位置，直到工具卡出现再升级展示。

## 4. 验证/定位清单（用来确认问题是哪一类）

1. **运行中是否曾经出现完整交错结构**  
   - 若出现过但结束后丢失：优先是根因 A（收尾覆盖）+ 根因 B（runId 丢失）。
2. **结束后工具卡是否从“分散的多张”变成“一坨聚合”**  
   - 是：说明 blocks 在最后一次写回时变成了 `{tool_use: taskId}` 或丢了 runId（根因 B）。
3. **空隙主要来自内容还是样式**  
   - 把对应文本段复制出来看是否含大量空行；若有优先做换行归一；若没有优先调 CSS。
4. **任务面板是否必然早于工具卡出现**  
   - 是：说明两者触发点不同（根因 D），需要对齐显示时机。

## 5. 实施顺序建议（最短路径）

1. 先修 3.1（收尾不回退 blocks）——这是“最后一刻替换/合并”的根因。
2. 再修 3.2（runId 不丢）——解决“最后工具卡合并成一坨”。
3. 再修 3.3（空隙收紧）——纯体验优化，不影响逻辑正确性。
4. 最后修 3.4（任务面板时序）——统一体验时序，避免割裂。

